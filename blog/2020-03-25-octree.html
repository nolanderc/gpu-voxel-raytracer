<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Christofer Nolander" />
  <meta name="dcterms.date" content="2020-03-25" />
  <title>Realtime Path Tracing on the GPU</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Realtime Path Tracing on the GPU</h1>
<p class="subtitle">The Octree Data Structure</p>
<p class="author">Christofer Nolander</p>
<p class="date">2020-03-25</p>
</header>
<p>In the previous post we introduced the concepts of path tracing and how to make it fast enough to run in real-time. As stated in that post, we will now look at how an <em>octree</em> will help us to reduce the cost of tracing a ray in the scene.</p>
<h1 id="a-three-d-tree">A Three-D Tree</h1>
<p>If you’ve taken a class in datastructures you are probably familiar with the concept of a tree: a parent node with some number of children nodes, each of which is also a tree. An octree is also a tree, but with the special property that every parent has exactly eight children, or “octants” (hence the name <em>oct</em>-tree, from <em>octo</em>, meaning eight). Every node in an octree represents a cube in 3D space, where the eight children are a subdivision of the parent cube. See this illustrative image:</p>
<figure>
<img src="resources/octree.png" alt="Illustration of an octree" /><figcaption aria-hidden="true">Illustration of an octree</figcaption>
</figure>
<p>There are analogs of <em>octree</em>s in other dimensions, such as a quadtree in 2D. Since it’s hard to show in pictures how an octree works, since its in 3D, everything below will be of quadtrees.</p>
<p>A common usecase for octrees is to quickly be able to determine what objects are at a given position. In this case, the root node of the octree should contain all the objects in the scene. For our given query-point we would then check which child of the root we are in, and then recursively traverse down that child until we hit some leaf node, which either contains some object or is empty.</p>
<h1 id="tracing-rays-in-an-octree">Tracing Rays in an Octree</h1>
<p>Octrees turn out to be really helpful when tracing a scene. If we were to trace a ray in the scene above, we are only interested in the nodes of the octree the ray intersects. Therefore, we may recursively, starting from the root, check which children of the tree the ray intersects. We may then recursively check every child’s children for intersections, and so on. Additionally, if a child happens to not have any children of its own, and isn’t a leaf, we may skip that one as well since we know the ray cannot intersect anything.</p>
<p>That last point happens to be very important since, in many scenes, there’s a lot of empty space. Because of this rays don’t often have to traverse the entire tree all the way down to the leaves. Instead they can skip many of the children, resulting very cheap traversal.</p>
<p>For simplicity, the path tracer developed here will only have one type of objects in the scene: cubes (can you guess why?). The cubes will be aligned on a grid. Similar to the mining-crafting game Minecraft. In the next post we will implement the octree and finally start rendering some cubes!</p>
<p><a href="2020-03-24-intro.html" style="float:left;">Previous Post</a> <a href="2020-03-26-ray-tracing.html" style="float:right;">Next Post</a></p>
</body>
</html>
