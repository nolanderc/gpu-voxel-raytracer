#version 450

#define MAX_DEPTH 15
#define MAX_BOUNCES 4
#define MAX_SAMPLES 1

#define SKY_COLOR vec3(0.01)
#define SUN_DIR vec3(0.2, -0.3, 0.1)
#define SUN_COLOR vec3(1, 1, 1)
#define SUN_SIZE .01

#define SPECULARITY 0.15
#define EMIT_STRENGTH 4

#define SAMPLE_BLENDING 0.3
#define MAXIMUM_BLENDING (0.01)
#define BLENDING_DISTANCE_CUTOFF 1e-2

#define ALMOST_INFINITY (1 << 30)

#define LEAF_BIT (1 << 31)
#define EMMITANCE_BIT (1 << 30)

#define PI 3.14159265358979

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, binding = 0) uniform readonly image2D temporal_image;
layout(rgba32f, binding = 1) uniform writeonly image2D output_image;

layout(rgba32f, binding = 2) uniform readonly image2D old_positions;
layout(rgba32f, binding = 3) uniform writeonly image2D new_positions;

layout(binding = 6) uniform uniforms {
    vec4 camera_origin;
    vec4 camera_right;
    vec4 camera_up;
    vec4 camera_forward;
    vec4 light;
    float global_time;
    uint still_sample;
};

layout(binding = 7) uniform old_uniforms {
    vec4 old_camera_origin;
    vec4 old_camera_right;
    vec4 old_camera_up;
    vec4 old_camera_forward;
};

layout(binding = 8) readonly buffer octree_data {
    vec3 root_center;
    float root_size;
    int nodes[];
};

#define RANDOM_FLOAT_COUNT (1 << 16)

layout(binding = 9) readonly buffer randomness {
    float random_floats[RANDOM_FLOAT_COUNT];
};

bool ray_cube_intersection(
    vec3 origin, vec3 inv_dir,
    vec3 center, float half_size,
    out float entry, out float exit
) {
    vec3 signum = sign(inv_dir);

    vec3 entry_planes = center - half_size * signum;
    vec3 exit_planes = center + half_size * signum;

    vec3 entries = (entry_planes - origin) * inv_dir;
    vec3 exits = (exit_planes - origin) * inv_dir;

    entry = max(max(entries.x, entries.y), entries.z);
    exit = min(min(exits.x, exits.y), exits.z);

    return exit >= 0 && entry < exit;
}

vec3 octant_center(vec3 center, float size, uint octant) {
    vec3 delta = vec3((octant >> 2) & 1, (octant >> 1) & 1, octant & 1);
    return center + 0.25 * size * sign(delta - 0.5);
}

struct OctantIntersections {
    uint octants_and_count;
    float entries[5];
};

void insert_octant(inout uint octants, uint octant, int octant_index) {
    octants = bitfieldInsert(octants, octant, 3 * (octant_index + 1), 3);
}

uint get_octant(uint octants, int octant_index) {
    return bitfieldExtract(octants, 3 * (octant_index + 1), 3);
}

// (1 <= count <= 4, so we store 0 <= count - 1 <= 3 using 2 bits)
void insert_count(inout uint octants, uint count) {
    octants = bitfieldInsert(octants, count - 1, 0, 2);
}

uint get_count(uint octants) {
    return (octants & 0x3) + 1;
}

uint current_octant(vec3 position, vec3 center) {
    vec3 delta = position - center;
    uint dx = delta.x > 0 ? 4 : 0; // (delta.x > 0 || (!(delta.x < 0) && inv_dir.x < 0)) ? 4 : 0;
    uint dy = delta.y > 0 ? 2 : 0; // (delta.y > 0 || (!(delta.y < 0) && inv_dir.y < 0)) ? 2 : 0;
    uint dz = delta.z > 0 ? 1 : 0; // (delta.z > 0 || (!(delta.z < 0) && inv_dir.z < 0)) ? 1 : 0;
    return dx + dy + dz;
}

struct Frame {
    int node;
    float exit;
    vec3 center;
    float size;
    uint octant;
} stack[MAX_DEPTH];

int iterations = 0;

bool cast_bounded_ray(
    vec3 ray_origin, vec3 ray_dir, float max_distance, 
    out float time, out int out_node, out vec3 normal
) {
    const uint dir_mask = (ray_dir.x < 0 ? 4 : 0) | (ray_dir.y < 0 ? 2 : 0) | (ray_dir.z < 0 ? 1 : 0);

    const vec3 ray_inv_dir = 1.0 / ray_dir;

    float root_entry, root_exit;
    bool intersect = ray_cube_intersection(
            ray_origin, ray_inv_dir, 
            root_center, 0.5 * root_size,
            root_entry, root_exit
        );

    if (!intersect) {
        return false;
    }

    int top = 0;

    time = max(0, root_entry);
    int node = 0;
    float exit = root_exit;
    vec3 center = root_center;
    float size = root_size;
    uint octant = current_octant(ray_origin + ray_dir * time, center);

    int value;

    iterations = 0;
    while(true) {
        iterations++;

        if (iterations >= 2048) { 
            out_node = LEAF_BIT;
            return true;
        };

        if (time > max_distance) {
            return false;
        }

        value = nodes[node + octant];

        if (value < 0) {
            // We found a value
            out_node = value;

            vec3 hit = ray_origin + time * ray_dir;
            vec3 octant_center = octant_center(center, size, octant);
            vec3 distances = abs(hit - octant_center);
            float max_dist = max(max(distances.x, distances.y), distances.z);
            bvec3 normal_mask = equal(distances, vec3(max_dist));
            normal = vec3(normal_mask) * -sign(ray_dir);

            return true;
        }

        vec3 t_mid = (center - ray_origin) * ray_inv_dir;

        uint directional_octant = octant ^ dir_mask;
        bvec3 locked = bvec3(directional_octant & 4, directional_octant & 2, directional_octant & 1);
        bvec3 ahead = greaterThanEqual(t_mid, vec3(time));

        vec3 mid_intersect = vec3(not(ahead)) * t_mid + vec3(ahead) * vec3(ALMOST_INFINITY);
        mid_intersect = vec3(not(locked)) * t_mid + vec3(locked) * vec3(ALMOST_INFINITY);

        float next_time = min(min(mid_intersect.x, mid_intersect.y), mid_intersect.z);
        bvec3 plane = equal(mid_intersect, vec3(next_time));
        uint transition = plane.x ? 4 : (plane.y ? 2 : (plane.z ? 1 : 0));

        uint next_octant = octant ^ transition;
        bool has_next = next_time <= exit && transition != 0 && (directional_octant & transition) == 0;

        if (value > 0) {
            // Push next to stack, and continue with child
            if (has_next) {
                stack[top].node = node;
                stack[top].exit = exit;
                stack[top].center = center;
                stack[top].size = size;
                stack[top].octant = next_octant;
                top++;
            }

            node = value;
            center = octant_center(center, size, octant);
            size = 0.5 * size;
            octant = current_octant(ray_origin + ray_dir * time, center);

            float octant_entry, octant_exit;
            ray_cube_intersection(ray_origin, ray_inv_dir, center, 0.5 * size, octant_entry, octant_exit);
            time = max(time, octant_entry);
            exit = octant_exit;
        } else if (has_next) {
            octant = next_octant;
            time = next_time;
        } else {
            // we couldn't advance, pop the stack and continue.

            // no more nodes, failed to intersect
            if (top == 0) return false;

            time = exit;

            top--;
            node = stack[top].node;
            exit = stack[top].exit;
            center = stack[top].center;
            size = stack[top].size;
            octant = stack[top].octant;
        }

        // Recurse
    }
}

bool cast_ray(vec3 ray_origin, vec3 ray_dir, out float time, out int node, out vec3 normal) {
    return cast_bounded_ray(ray_origin, ray_dir, ALMOST_INFINITY, time, node, normal);
}

vec3 node_color(int node) {
    float r = float((node >> 16) & 0xff);
    float g = float((node >> 8) & 0xff);
    float b = float(node & 0xff);
    return vec3(r, g, b) / 255.0;
}

vec3 node_emmitance(int node) {
    float e = float((node & EMMITANCE_BIT) != 0);
    float r = float((node >> 16) & 0xff);
    float g = float((node >> 8) & 0xff);
    float b = float(node & 0xff);
    return e * EMIT_STRENGTH * vec3(r, g, b) / 255.0;
}

uint random_index = (gl_GlobalInvocationID.x * gl_GlobalInvocationID.y) % RANDOM_FLOAT_COUNT;
float rand() {
    random_index = (random_index + 1) % RANDOM_FLOAT_COUNT;
    return random_floats[random_index];
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    vec3 out_color = vec3(0);
    vec3 albedo = vec3(0);
    vec3 world_pos = vec3(ALMOST_INFINITY);
    vec3 first_normal = vec3(ALMOST_INFINITY);
    float first_time = 0;
    bool hit = false;
    int first_node = 0;

    for (int sampl = 0; sampl < MAX_SAMPLES; sampl++) {
        vec3 ray_origin = camera_origin.xyz;
        vec3 ray_dir = normalize(
            (coord.x + 0.5) * camera_right.xyz 
            - (coord.y + 0.5) * camera_up.xyz 
            + camera_forward.xyz
        );

        vec3 sample_color = vec3(0);
        vec3 blending_factor = vec3(1);

        for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
            float time;
            int node;
            vec3 normal;
            if (cast_ray(ray_origin, ray_dir, time, node, normal)) {
                vec3 hit_pos = ray_origin + ray_dir * time;
                vec3 color = node_color(node);
                vec3 emmitance = node_emmitance(node);

                if (!hit) {
                    first_node = node;
                    albedo = color;
                    world_pos = hit_pos;
                    first_normal = normal;
                    hit = true;
                    first_time = time;
                }

                random_index += uint(node) + uint(time * 1238951);

                float phi = 2 * PI * rand();
                vec3 reflect_dir;
                reflect_dir.x = 2 * rand() - 1;
                float plane_radius = sqrt(1 - reflect_dir.x*reflect_dir.x);
                reflect_dir.y = plane_radius * cos(phi);
                reflect_dir.z = plane_radius * sin(phi);

                reflect_dir -= normal * min(0, 2 * dot(normal, reflect_dir));

                vec3 reflection = reflect(ray_dir, normal);
                reflect_dir = normalize(mix(reflect_dir, reflection, SPECULARITY));

                sample_color += emmitance * blending_factor;
                blending_factor *= mix(2, 1, SPECULARITY) * color * dot(normal, reflect_dir);
                //blending_factor *= color;

                ray_origin = hit_pos + 1e-5 * normal;
                ray_dir = reflect_dir;

                // CAST SUN RAY
                vec3 rand_dir = vec3(rand(), rand(), rand());
                vec3 up_dir = normalize(cross(rand_dir, SUN_DIR));
                vec3 right_dir = normalize(cross(SUN_DIR, up_dir));

                float dx = 2 * rand() - 1;
                float dy = 2 * rand() - 1;

                vec3 light_dir = normalize(SUN_DIR) + (dx * right_dir + dy * up_dir) * SUN_SIZE;

                float sun_time;
                int sun_node;
                vec3 sun_normal;
                bool sun_obstructed = cast_ray(
                    ray_origin, normalize(-light_dir),
                    sun_time, sun_node, sun_normal
                );

                if (!sun_obstructed) {
                    sample_color += SUN_COLOR * blending_factor;
                }
            } else {
                if (bounce == 0) {
                    blending_factor = vec3(1);
                }

                // hit the sky
                float sun_power = pow(
                    max(0, dot(ray_dir, normalize(-SUN_DIR))), 
                    1.0 / pow(SUN_SIZE, 2)
                );
                sample_color += (SKY_COLOR + SUN_COLOR * sun_power) * blending_factor;
                break;
            }
        }

        out_color += sample_color;
    }

    out_color /= MAX_SAMPLES;

    vec4 old_color = vec4(out_color, 1);

    float normal_encoding = abs(dot(first_normal, vec3(0.5, 2.5, 4.5))) + dot(first_normal, vec3(0.5));

    float blending = 1;
    if (hit) {
        mat4 old_screen_to_world = mat4(
                vec4(old_camera_right.xyz, 0),
                vec4(old_camera_up.xyz, 0),
                vec4(old_camera_forward.xyz, 0),
                vec4(old_camera_origin.xyz, 1)
                );

        vec4 old_screen = inverse(old_screen_to_world) * vec4(world_pos, 1);
        // old_screen = new_screen;
        old_screen.xyz /= old_screen.z;
        ivec2 old_coord = ivec2(old_screen.x, -old_screen.y);

        ivec2 size = imageSize(temporal_image);

        if (0 <= old_coord.x && old_coord.x < size.x && 0 <= old_coord.y && old_coord.y < size.y) {
            vec4 old_position = imageLoad(old_positions, old_coord);
            vec3 old_world_pos = old_position.xyz;
            float old_normal_encoding = old_position.w;

            vec3 camera_dir = normalize(camera_origin.xyz - world_pos);

            float bias = max(0, dot(camera_dir, first_normal));
            bool same_position = bias * distance(world_pos, old_world_pos) <
                BLENDING_DISTANCE_CUTOFF * first_time;
            bool same_normal = normal_encoding == old_normal_encoding;

            if (same_position && same_normal) {
                old_color = imageLoad(temporal_image, old_coord);
                blending = SAMPLE_BLENDING;
            }
        }
    }

    blending = still_sample <= 2 ? blending : min(blending, max(MAXIMUM_BLENDING, 1.0 / still_sample));

    vec3 new_color = hit ? mix(old_color.rgb, out_color, blending) : out_color;
    imageStore(output_image, coord, vec4(new_color, 10 * first_node + 100 * normal_encoding));
    imageStore(new_positions, coord, vec4(world_pos, normal_encoding));
}
