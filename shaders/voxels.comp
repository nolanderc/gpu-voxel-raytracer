#version 450

#define MAX_DEPTH 15
#define MAX_BOUNCES 3
#define MAX_SAMPLES 1

#define SKY_COLOR vec3(0.3, 0.7, 0.8)
#define SUN_DIR vec3(0.2 * cos(0.1 * global_time), -0.2, 0.1 * sin(0.1 * global_time))
#define SUN_COLOR (0.5 * vec3(5, 5, 3))
#define SUN_SIZE 0.03

#define SPECULARITY 0.05
#define EMIT_STRENGTH 4

#define SAMPLE_BLENDING 0.9
#define MAXIMUM_BLENDING 0.05
#define BLENDING_DISTANCE_CUTOFF 1e-2

#define ALMOST_INFINITY (1 << 30)

#define LEAF_BIT (1 << 31)
#define EMMITANCE_BIT (1 << 30)

#define PI 3.14159265358979

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) uniform texture2D temporal_image;
layout(binding = 10) uniform sampler temporal_sampler;

layout(rgba32f, binding = 1) uniform writeonly image2D output_image;

layout(binding = 2) uniform texture2D old_positions;
layout(rgba32f, binding = 3) uniform writeonly image2D new_positions;

layout(binding = 6) uniform uniforms {
    vec4 camera_origin;
    vec4 camera_right;
    vec4 camera_up;
    vec4 camera_forward;
    vec4 light;
    float global_time;
    uint still_sample;
    uint frame_number;
};

layout(binding = 7) uniform old_uniforms {
    vec4 old_camera_origin;
    vec4 old_camera_right;
    vec4 old_camera_up;
    vec4 old_camera_forward;
};

layout(binding = 8) readonly buffer octree_data {
    vec3 root_center;
    float root_size;
    float child_size;
    int nodes[];
};

#define BLUE_NOISE_SIZE 128
#define BLUE_NOISE_COUNT 512
#define BLUE_NOISE_BUFFER_SIZE (BLUE_NOISE_SIZE * BLUE_NOISE_SIZE * BLUE_NOISE_COUNT)

layout(binding = 9) readonly buffer randomness {
    float blue_noise[BLUE_NOISE_BUFFER_SIZE];
};

bool ray_cube_intersection(
    vec3 origin, vec3 inv_dir,
    vec3 center, float half_size,
    out float entry, out float exit
) {
    vec3 signum = sign(inv_dir);

    vec3 entry_planes = center - half_size * signum;
    vec3 exit_planes = center + half_size * signum;

    vec3 entries = (entry_planes - origin) * inv_dir;
    vec3 exits = (exit_planes - origin) * inv_dir;

    entry = max(max(entries.x, entries.y), entries.z);
    exit = min(min(exits.x, exits.y), exits.z);

    return exit >= 0 && entry < exit;
}

vec3 octant_center(vec3 center, float size, uint octant) {
    vec3 delta = vec3((octant >> 2) & 1, (octant >> 1) & 1, octant & 1);
    return center + 0.5 * size * (delta - 0.5);
}

struct OctantIntersections {
    uint octants_and_count;
    float entries[5];
};

void insert_octant(inout uint octants, uint octant, int octant_index) {
    octants = bitfieldInsert(octants, octant, 3 * (octant_index + 1), 3);
}

uint get_octant(uint octants, int octant_index) {
    return bitfieldExtract(octants, 3 * (octant_index + 1), 3);
}

// (1 <= count <= 4, so we store 0 <= count - 1 <= 3 using 2 bits)
void insert_count(inout uint octants, uint count) {
    octants = bitfieldInsert(octants, count - 1, 0, 2);
}

uint get_count(uint octants) {
    return (octants & 0x3) + 1;
}

uint current_octant(vec3 position, vec3 center) {
    vec3 delta = position - center;
    uint dx = delta.x > 0 ? 4 : 0; // (delta.x > 0 || (!(delta.x < 0) && inv_dir.x < 0)) ? 4 : 0;
    uint dy = delta.y > 0 ? 2 : 0; // (delta.y > 0 || (!(delta.y < 0) && inv_dir.y < 0)) ? 2 : 0;
    uint dz = delta.z > 0 ? 1 : 0; // (delta.z > 0 || (!(delta.z < 0) && inv_dir.z < 0)) ? 1 : 0;
    return dx + dy + dz;
}

struct Frame {
    int node;
    uint octant;
    float exit;
} stack[MAX_DEPTH];

int iterations = 0;

bool cast_bounded_ray(
    vec3 ray_origin, vec3 ray_dir, float max_distance, 
    out float time, out int out_node, out vec3 normal
) {
    const uint dir_mask = (ray_dir.x < 0 ? 4 : 0) | (ray_dir.y < 0 ? 2 : 0) | (ray_dir.z < 0 ? 1 : 0);

    const vec3 ray_inv_dir = 1.0 / ray_dir;

    float root_entry, root_exit;
    bool intersect = ray_cube_intersection(
            ray_origin, ray_inv_dir, 
            root_center, 0.5 * root_size,
            root_entry, root_exit
        );

    if (!intersect) {
        return false;
    }

    int top = 0;

    time = max(0, root_entry);
    int node = 0;
    float exit = root_exit;
    vec3 center = root_center;
    float size = root_size;
    uint octant = current_octant(ray_origin + ray_dir * time, center);

    iterations = 0;
    while(true) {
        iterations++;

        if (iterations >= 2048) { 
            out_node = LEAF_BIT;
            return true;
        };

        if (time > max_distance) {
            return false;
        }

        int value = nodes[8 * node + octant];

        if (value < 0) {
            // We found a value
            out_node = value;

            vec3 hit = ray_origin + time * ray_dir;
            vec3 octant_center = octant_center(center, size, octant);
            vec3 distances = abs(hit - octant_center);
            float max_dist = max(max(distances.x, distances.y), distances.z);
            bvec3 normal_mask = equal(distances, vec3(max_dist));
            normal = vec3(normal_mask) * -sign(ray_dir);

            return true;
        }

        vec3 t_mid = (center - ray_origin) * ray_inv_dir;

        uint directional_octant = octant ^ dir_mask;
        bvec3 locked = bvec3(directional_octant & 4, directional_octant & 2, directional_octant & 1);
        bvec3 ahead = greaterThanEqual(t_mid, vec3(time));

        vec3 mid_intersect = vec3(not(ahead)) * t_mid + vec3(ahead) * vec3(ALMOST_INFINITY);
        mid_intersect = vec3(not(locked)) * t_mid + vec3(locked) * vec3(ALMOST_INFINITY);

        float next_time = min(min(mid_intersect.x, mid_intersect.y), mid_intersect.z);
        bvec3 plane = equal(mid_intersect, vec3(next_time));
        uint transition = plane.x ? 4 : (plane.y ? 2 : (plane.z ? 1 : 0));

        uint next_octant = octant ^ transition;
        bool has_next = next_time <= exit && transition != 0 && (directional_octant & transition) == 0;

        if (value > 0) {
            // Push next to stack, and continue with child
            if (has_next) {
                stack[top].node = node;
                stack[top].exit = exit;
                // stack[top].center = center;
                // stack[top].size = size;
                stack[top].octant = (next_octant << 3) | octant;
                top++;
            } else {
                // mark node as complete
                stack[top].node = -1;
                stack[top].octant = octant;
                top++;
            }

            node = value;
            center = octant_center(center, size, octant);
            size *= 0.5;
            octant = current_octant(ray_origin + ray_dir * time, center);

            float octant_entry, octant_exit;
            ray_cube_intersection(ray_origin, ray_inv_dir, center, 0.5 * size, octant_entry, octant_exit);
            time = max(time, octant_entry);
            exit = octant_exit;
        } else if (has_next) {
            octant = next_octant;
            time = next_time;
        } else {
            // we couldn't advance, pop the stack and continue.
            do {
                if (top == 0) return false;
                top--;
                node = stack[top].node;
                size *= 2;
                uint parent_octant = stack[top].octant & 0x7;
                center = octant_center(center, size, ~parent_octant);
            } while(/* skip complete nodes */node < 0);

            time = exit;

            exit = stack[top].exit;
            // center = stack[top].center;
            // size = stack[top].size;
            octant = (stack[top].octant >> 3) & 0x7;
        }

        // Recurse
    }
}

bool cast_ray(vec3 ray_origin, vec3 ray_dir, out float time, out int node, out vec3 normal) {
    return cast_bounded_ray(ray_origin, ray_dir, ALMOST_INFINITY, time, node, normal);
}

vec3 node_color(int node) {
    float r = float((node >> 16) & 0xff);
    float g = float((node >> 8) & 0xff);
    float b = float(node & 0xff);
    return vec3(r, g, b) / 255.0;
}

vec3 node_emmitance(int node) {
    float e = float((node & EMMITANCE_BIT) != 0);
    float r = float((node >> 16) & 0xff);
    float g = float((node >> 8) & 0xff);
    float b = float(node & 0xff);
    return e * EMIT_STRENGTH * vec3(r, g, b) / 255.0;
}

uint random_index = gl_GlobalInvocationID.x % BLUE_NOISE_SIZE 
    + (gl_GlobalInvocationID.y % BLUE_NOISE_SIZE) * BLUE_NOISE_SIZE
    + (frame_number % BLUE_NOISE_COUNT) * BLUE_NOISE_SIZE * BLUE_NOISE_SIZE;
float rand() {
    random_index = (random_index + BLUE_NOISE_SIZE * BLUE_NOISE_SIZE) % BLUE_NOISE_BUFFER_SIZE;
    return blue_noise[random_index];
}

vec3 random_hemisphere(vec3 normal) {
    float phi = 2 * PI * rand();
    vec3 reflect_dir;
    reflect_dir.x = 2 * rand() - 1;
    float plane_radius = sqrt(1 - reflect_dir.x*reflect_dir.x);
    reflect_dir.y = plane_radius * cos(phi);
    reflect_dir.z = plane_radius * sin(phi);

    reflect_dir -= normal * min(0, 2 * dot(normal, reflect_dir));
    return reflect_dir;
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    vec3 out_color = vec3(0);
    vec3 albedo = vec3(0);
    vec3 world_pos = vec3(ALMOST_INFINITY);
    vec3 first_normal = vec3(ALMOST_INFINITY);
    float first_time = 0;
    bool hit = false;
    int first_node = 0;

    for (int sampl = 0; sampl < MAX_SAMPLES; sampl++) {
        vec3 ray_origin = camera_origin.xyz;
        vec3 ray_dir = normalize(
            (coord.x + 0.5) * camera_right.xyz 
            - (coord.y + 0.5) * camera_up.xyz 
            + camera_forward.xyz
        );

        vec3 sample_color = vec3(0);
        vec3 blending_factor = vec3(1);
        uint rays = 1;

        for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
            float time;
            int node;
            vec3 normal;
            if (cast_ray(ray_origin, ray_dir, time, node, normal)) {
                vec3 hit_pos = ray_origin + ray_dir * time;
                vec3 color = node_color(node);
                vec3 emmitance = node_emmitance(node);

                if (!hit) {
                    first_node = node;
                    albedo = color;
                    world_pos = hit_pos;
                    first_normal = normal;
                    hit = true;
                    first_time = time;
                }

                // === Cast sun ray ===
                vec3 rand_dir = vec3(rand(), rand(), rand());
                vec3 up_dir = normalize(cross(rand_dir, SUN_DIR));
                vec3 right_dir = normalize(cross(SUN_DIR, up_dir));

                float dx = 2 * rand() - 1;
                float dy = 2 * rand() - 1;

                vec3 light_dir = normalize(SUN_DIR) + (dx * right_dir + dy * up_dir) * SUN_SIZE;

                float sun_time;
                int sun_node;
                vec3 sun_normal;
                bool sun_obstructed = cast_ray(
                    hit_pos + 1e-5 * normal, normalize(-light_dir),
                    sun_time, sun_node, sun_normal
                );

                if (!sun_obstructed) {
                    //rays++;
                    sample_color += SUN_COLOR * color * blending_factor * mix(1, 0, SPECULARITY) * max(0, dot(normal, normalize(-light_dir)));
                }


                // === Sample BRDF ===
                vec3 reflection = reflect(ray_dir, normal);
                vec3 reflect_dir = normalize(mix(random_hemisphere(normal), reflection, SPECULARITY));

                sample_color += emmitance * blending_factor;
                blending_factor *= color * mix(2, 1, SPECULARITY) * dot(normal, reflect_dir);
                //blending_factor *= color;

                ray_origin = hit_pos + 1e-5 * normal;
                ray_dir = reflect_dir;

            } else {
                if (bounce == 0) {
                    blending_factor = vec3(1);
                }

                // hit the sky
                float sun_power = pow(
                    max(0, dot(ray_dir, normalize(-SUN_DIR))), 
                    1.0 / pow(SUN_SIZE, 2)
                );
                sample_color += (SKY_COLOR + SUN_COLOR * sun_power) * blending_factor;
                break;
            }
        }

        out_color += sample_color / rays;
    }

    out_color /= MAX_SAMPLES;

    vec4 old_color = vec4(out_color, 1);

    float normal_encoding = abs(dot(first_normal, vec3(0.5, 2.5, 4.5))) + dot(first_normal, vec3(0.5));

    float blending = 1;
    if (hit) {
        mat4 old_screen_to_world = mat4(
                vec4(old_camera_right.xyz, 0),
                vec4(old_camera_up.xyz, 0),
                vec4(old_camera_forward.xyz, 0),
                vec4(old_camera_origin.xyz, 1)
                );

        vec4 old_screen = inverse(old_screen_to_world) * vec4(world_pos, 1);
        // old_screen = new_screen;
        old_screen.xyz /= old_screen.z;
        ivec2 old_coord = ivec2(old_screen.x, -old_screen.y);

        ivec2 size = textureSize(sampler2D(temporal_image, temporal_sampler), 0);

        if (0 <= old_coord.x && old_coord.x < size.x && 0 <= old_coord.y && old_coord.y < size.y) {
            vec2 tex_coord = old_screen.xy * vec2(1.0 / size.x, -1.0 / size.y);

            vec4 old_position = texture(sampler2D(old_positions, temporal_sampler), tex_coord);
            vec3 old_world_pos = old_position.xyz;
            float old_normal_encoding = old_position.w;

            vec3 camera_dir = normalize(camera_origin.xyz - world_pos);

            float bias = max(0.1, dot(camera_dir, first_normal));
            float dist = distance(world_pos, old_world_pos);

            bool same_position = bias * dist < 1e-2 * child_size;
            bool same_normal = normal_encoding == old_normal_encoding 
                || bias * dist < 1e-1 * child_size * first_time;

            if (same_normal && same_position) {
                old_color = texture(sampler2D(temporal_image, temporal_sampler), tex_coord); 
                blending = old_color.a;
            }
        }
    }

    float next_blending = max(SAMPLE_BLENDING * blending, MAXIMUM_BLENDING);
    if (still_sample <= 2) {
        next_blending = min(next_blending, 1.0 / still_sample);
    }

    vec3 new_color = hit ? mix(old_color.rgb, out_color, blending) : out_color;
    imageStore(output_image, coord, vec4(new_color, next_blending));
    imageStore(new_positions, coord, vec4(world_pos, normal_encoding));
}
