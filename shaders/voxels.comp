#version 450

#define MAX_DEPTH 15

#define ALMOST_INFINITY (1 << 30)

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform writeonly image2D output_image;

layout(binding = 1) uniform uniforms {
    vec4 camera_origin;
    vec4 camera_right;
    vec4 camera_up;
    vec4 camera_forward;
    vec4 light;
    float time;
};

layout(binding = 2) readonly buffer octree_data {
    vec3 root_center;
    float root_size;
    int nodes[];
};

bool ray_cube_intersection(
    vec3 origin, vec3 inv_dir,
    vec3 center, float half_size,
    out float entry, out float exit
) {
    vec3 signum = sign(inv_dir);

    vec3 entry_planes = center - half_size * signum;
    vec3 exit_planes = center + half_size * signum;

    vec3 entries = (entry_planes - origin) * inv_dir;
    vec3 exits = (exit_planes - origin) * inv_dir;

    entry = max(max(entries.x, entries.y), entries.z);
    exit = min(min(exits.x, exits.y), exits.z);

    return exit >= 0 && entry < exit;
}

vec3 octant_center(vec3 center, float size, uint octant) {
    vec3 delta = vec3((octant >> 2) & 1, (octant >> 1) & 1, octant & 1);
    return center + 0.25 * size * sign(delta - 0.5);
}

struct OctantIntersections {
    uint octants_and_count;
    float entries[5];
};

void insert_octant(inout uint octants, uint octant, int octant_index) {
    octants = bitfieldInsert(octants, octant, 3 * (octant_index + 1), 3);
}

uint get_octant(uint octants, int octant_index) {
    return bitfieldExtract(octants, 3 * (octant_index + 1), 3);
}

// (1 <= count <= 4, so we store 0 <= count - 1 <= 3 using 2 bits)
void insert_count(inout uint octants, uint count) {
    octants = bitfieldInsert(octants, count - 1, 0, 2);
}

uint get_count(uint octants) {
    return (octants & 0x3) + 1;
}

uint current_octant(vec3 position, vec3 center) {
    vec3 delta = position - center;
    uint dx = delta.x > 0 ? 4 : 0; // (delta.x > 0 || (!(delta.x < 0) && inv_dir.x < 0)) ? 4 : 0;
    uint dy = delta.y > 0 ? 2 : 0; // (delta.y > 0 || (!(delta.y < 0) && inv_dir.y < 0)) ? 2 : 0;
    uint dz = delta.z > 0 ? 1 : 0; // (delta.z > 0 || (!(delta.z < 0) && inv_dir.z < 0)) ? 1 : 0;
    return dx + dy + dz;
}

struct Frame {
    int node;
    float exit;
    vec3 center;
    float size;
    uint octant;
};

int iterations = 0;
bool cast_ray(vec3 ray_origin, vec3 ray_dir, out float time, out vec3 color, out vec3 normal) {
    const uint dir_mask = (ray_dir.x < 0 ? 4 : 0) | (ray_dir.y < 0 ? 2 : 0) | (ray_dir.z < 0 ? 1 : 0);

    const vec3 ray_inv_dir = 1.0 / ray_dir;

    float root_entry, root_exit;
    bool intersect = ray_cube_intersection(
            ray_origin, ray_inv_dir, 
            root_center, 0.5 * root_size,
            root_entry, root_exit
        );

    if (!intersect) {
        return false;
    }

    Frame stack[MAX_DEPTH];
    int top = 0;

    time = max(0, root_entry);
    int node = 0;
    float exit = root_exit;
    vec3 center = root_center;
    float size = root_size;
    uint octant = current_octant(ray_origin + ray_dir * time, center);

    int value;

    while(true) {
        iterations++;

        if (iterations >= 128) { 
            color = vec3(0);
            return true;
        };

        value = nodes[node + octant];

        if (value < 0) {
            // We found a value
            color = vec3((value >> 16) & 0xff, (value >> 8) & 0xff, (value) & 0xff) / 255.0;

            vec3 hit = ray_origin + time * ray_dir;
            vec3 octant_center = octant_center(center, size, octant);
            vec3 distances = abs(hit - octant_center);
            float max_dist = max(max(distances.x, distances.y), distances.z);
            bvec3 normal_mask = equal(distances, vec3(max_dist));
            normal = vec3(normal_mask) * -sign(ray_dir);

            return true;
        }

        vec3 t_mid = (center - ray_origin) * ray_inv_dir;

        uint directional_octant = octant ^ dir_mask;
        bvec3 locked = bvec3(directional_octant & 4, directional_octant & 2, directional_octant & 1);
        bvec3 ahead = greaterThanEqual(t_mid, vec3(time));

        vec3 mid_intersect = vec3(not(ahead)) * t_mid + vec3(ahead) * vec3(ALMOST_INFINITY);
        mid_intersect = vec3(not(locked)) * t_mid + vec3(locked) * vec3(ALMOST_INFINITY);

        float next_time = min(min(mid_intersect.x, mid_intersect.y), mid_intersect.z);
        bvec3 plane = equal(mid_intersect, vec3(next_time));
        // uint transition = uint(dot(vec3(plane), vec3(4, 2, 1)));
        uint transition = plane.x ? 4 : (plane.y ? 2 : (plane.z ? 1 : 0));

        uint next_octant = octant ^ transition;
        bool has_next = next_time <= exit && transition != 0 && (directional_octant & transition) == 0;

        if (value > 0) {
            // Push next to stack, and continue with child
            if (has_next) {
                stack[top].node = node;
                stack[top].exit = exit;
                stack[top].center = center;
                stack[top].size = size;
                stack[top].octant = next_octant;
                top++;
            }

            node = value;
            center = octant_center(center, size, octant);
            size = 0.5 * size;
            octant = current_octant(ray_origin + ray_dir * time, center);

            float octant_entry, octant_exit;
            ray_cube_intersection(ray_origin, ray_inv_dir, center, 0.5 * size, octant_entry, octant_exit);
            time = max(time, octant_entry);
            exit = octant_exit;
        } else if (has_next) {
            octant = next_octant;
            time = next_time;
        } else {
            // we couldn't advance, pop the stack and continue.

            // no more nodes, failed to intersect
            if (top == 0) return false;

            time = exit;

            top--;
            node = stack[top].node;
            exit = stack[top].exit;
            center = stack[top].center;
            size = stack[top].size;
            octant = stack[top].octant;
        }

        // Recurse
    }
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    vec3 ray_origin = camera_origin.xyz;
    vec3 ray_dir = normalize(
        (coord.x + 0.5) * camera_right.xyz 
        - (coord.y + 0.5) * camera_up.xyz 
        + camera_forward.xyz
    );
    
    float time;
    vec3 color, normal;
    bool hit = cast_ray(ray_origin, ray_dir, time, color, normal);

    vec3 out_color;

    const float ambient = 0.004;
    if (hit) {
        vec3 hit_point = ray_origin + ray_dir * (0.99999 * time);

        vec3 light_dir = normalize(hit_point - light.xyz);

        float shadow_time;
        vec3 shadow_color, shadow_normal;
        bool obstructed = cast_ray(hit_point, -light_dir, shadow_time, shadow_color, shadow_normal);
        float light_distance = distance(hit_point, light.xyz);
        bool shadow = obstructed && shadow_time <= light_distance;

        float diffuse = light.w * max(0.0, dot(-light_dir, normal)) / pow(light_distance, 2);
        float brightness = ambient + (shadow ? 0.2 * diffuse : diffuse);
        out_color = color * brightness;
    } else {
        out_color = vec3(abs(ray_dir));
    }

    imageStore(output_image, coord, vec4(out_color, 1));
}
