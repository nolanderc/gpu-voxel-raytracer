#version 450

#define MAX_DEPTH 10
#define MAX_BOUNCES 4
#define MAX_SAMPLES 8

#define ALMOST_INFINITY (1 << 30)

#define LEAF_BIT (1 << 31)
#define EMMITANCE_BIT (1 << 30)

#define PI 3.14159265358979

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform writeonly image2D output_image;

layout(binding = 1) uniform uniforms {
    vec4 camera_origin;
    vec4 camera_right;
    vec4 camera_up;
    vec4 camera_forward;
    vec4 light;
    float time;
};

layout(binding = 2) readonly buffer octree_data {
    vec3 root_center;
    float root_size;
    int nodes[];
};

#define RANDOM_FLOAT_COUNT (1 << 16)

layout(binding = 3) readonly buffer randomness {
    float random_floats[RANDOM_FLOAT_COUNT];
};


bool ray_cube_intersection(
    vec3 origin, vec3 inv_dir,
    vec3 center, float half_size,
    out float entry, out float exit
) {
    vec3 signum = sign(inv_dir);

    vec3 entry_planes = center - half_size * signum;
    vec3 exit_planes = center + half_size * signum;

    vec3 entries = (entry_planes - origin) * inv_dir;
    vec3 exits = (exit_planes - origin) * inv_dir;

    entry = max(max(entries.x, entries.y), entries.z);
    exit = min(min(exits.x, exits.y), exits.z);

    return exit >= 0 && entry < exit;
}

vec3 octant_center(vec3 center, float size, uint octant) {
    vec3 delta = vec3((octant >> 2) & 1, (octant >> 1) & 1, octant & 1);
    return center + 0.25 * size * sign(delta - 0.5);
}

struct OctantIntersections {
    uint octants_and_count;
    float entries[5];
};

void insert_octant(inout uint octants, uint octant, int octant_index) {
    octants = bitfieldInsert(octants, octant, 3 * (octant_index + 1), 3);
}

uint get_octant(uint octants, int octant_index) {
    return bitfieldExtract(octants, 3 * (octant_index + 1), 3);
}

// (1 <= count <= 4, so we store 0 <= count - 1 <= 3 using 2 bits)
void insert_count(inout uint octants, uint count) {
    octants = bitfieldInsert(octants, count - 1, 0, 2);
}

uint get_count(uint octants) {
    return (octants & 0x3) + 1;
}

uint current_octant(vec3 position, vec3 center) {
    vec3 delta = position - center;
    uint dx = delta.x > 0 ? 4 : 0; // (delta.x > 0 || (!(delta.x < 0) && inv_dir.x < 0)) ? 4 : 0;
    uint dy = delta.y > 0 ? 2 : 0; // (delta.y > 0 || (!(delta.y < 0) && inv_dir.y < 0)) ? 2 : 0;
    uint dz = delta.z > 0 ? 1 : 0; // (delta.z > 0 || (!(delta.z < 0) && inv_dir.z < 0)) ? 1 : 0;
    return dx + dy + dz;
}

struct Frame {
    int node;
    float exit;
    vec3 center;
    float size;
    uint octant;
} stack[MAX_DEPTH];

int iterations = 0;

bool cast_bounded_ray(
    vec3 ray_origin, vec3 ray_dir, float max_distance, 
    out float time, out int out_node, out vec3 normal
) {
    const uint dir_mask = (ray_dir.x < 0 ? 4 : 0) | (ray_dir.y < 0 ? 2 : 0) | (ray_dir.z < 0 ? 1 : 0);

    const vec3 ray_inv_dir = 1.0 / ray_dir;

    float root_entry, root_exit;
    bool intersect = ray_cube_intersection(
            ray_origin, ray_inv_dir, 
            root_center, 0.5 * root_size,
            root_entry, root_exit
        );

    if (!intersect) {
        return false;
    }

    int top = 0;

    time = max(0, root_entry);
    int node = 0;
    float exit = root_exit;
    vec3 center = root_center;
    float size = root_size;
    uint octant = current_octant(ray_origin + ray_dir * time, center);

    int value;

    iterations = 0;
    while(true) {
        iterations++;

        if (iterations >= 2048) { 
            out_node = LEAF_BIT;
            return true;
        };

        if (time > max_distance) {
            return false;
        }

        value = nodes[node + octant];

        if (value < 0) {
            // We found a value
            out_node = value;

            vec3 hit = ray_origin + time * ray_dir;
            vec3 octant_center = octant_center(center, size, octant);
            vec3 distances = abs(hit - octant_center);
            float max_dist = max(max(distances.x, distances.y), distances.z);
            bvec3 normal_mask = equal(distances, vec3(max_dist));
            normal = vec3(normal_mask) * -sign(ray_dir);

            return true;
        }

        vec3 t_mid = (center - ray_origin) * ray_inv_dir;

        uint directional_octant = octant ^ dir_mask;
        bvec3 locked = bvec3(directional_octant & 4, directional_octant & 2, directional_octant & 1);
        bvec3 ahead = greaterThanEqual(t_mid, vec3(time));

        vec3 mid_intersect = vec3(not(ahead)) * t_mid + vec3(ahead) * vec3(ALMOST_INFINITY);
        mid_intersect = vec3(not(locked)) * t_mid + vec3(locked) * vec3(ALMOST_INFINITY);

        float next_time = min(min(mid_intersect.x, mid_intersect.y), mid_intersect.z);
        bvec3 plane = equal(mid_intersect, vec3(next_time));
        uint transition = plane.x ? 4 : (plane.y ? 2 : (plane.z ? 1 : 0));

        uint next_octant = octant ^ transition;
        bool has_next = next_time <= exit && transition != 0 && (directional_octant & transition) == 0;

        if (value > 0) {
            // Push next to stack, and continue with child
            if (has_next) {
                stack[top].node = node;
                stack[top].exit = exit;
                stack[top].center = center;
                stack[top].size = size;
                stack[top].octant = next_octant;
                top++;
            }

            node = value;
            center = octant_center(center, size, octant);
            size = 0.5 * size;
            octant = current_octant(ray_origin + ray_dir * time, center);

            float octant_entry, octant_exit;
            ray_cube_intersection(ray_origin, ray_inv_dir, center, 0.5 * size, octant_entry, octant_exit);
            time = max(time, octant_entry);
            exit = octant_exit;
        } else if (has_next) {
            octant = next_octant;
            time = next_time;
        } else {
            // we couldn't advance, pop the stack and continue.

            // no more nodes, failed to intersect
            if (top == 0) return false;

            time = exit;

            top--;
            node = stack[top].node;
            exit = stack[top].exit;
            center = stack[top].center;
            size = stack[top].size;
            octant = stack[top].octant;
        }

        // Recurse
    }
}

bool cast_ray(vec3 ray_origin, vec3 ray_dir, out float time, out int node, out vec3 normal) {
    return cast_bounded_ray(ray_origin, ray_dir, ALMOST_INFINITY, time, node, normal);
}

vec3 node_color(int node) {
    float r = float((node >> 16) & 0xff);
    float g = float((node >> 8) & 0xff);
    float b = float(node & 0xff);
    return vec3(r, g, b) / 255.0;
}

vec3 node_emmitance(int node) {
    float e = float((node & EMMITANCE_BIT) != 0);
    float r = float((node >> 16) & 0xff);
    float g = float((node >> 8) & 0xff);
    float b = float(node & 0xff);
    return e * vec3(r, g, b) / 255.0;
}

uint random_index = (gl_GlobalInvocationID.x * gl_GlobalInvocationID.y) % RANDOM_FLOAT_COUNT;
float rand() {
    random_index = (random_index + 1) % RANDOM_FLOAT_COUNT;
    return random_floats[random_index];
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    vec3 start_ray_origin = camera_origin.xyz;
    vec3 start_ray_dir = normalize(
        (coord.x + 0.5) * camera_right.xyz 
        - (coord.y + 0.5) * camera_up.xyz 
        + camera_forward.xyz
    );
    
    const vec3 sky = vec3(0.0);

    vec3 out_color = vec3(0);

    for (int sampl = 0; sampl < MAX_SAMPLES; sampl++) {
        vec3 ray_origin = start_ray_origin;
        vec3 ray_dir = start_ray_dir;

        vec3 sample_color = vec3(0);
        vec3 blending_factor = vec3(1);

        for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
            float time;
            int node;
            vec3 normal;
            if (cast_ray(ray_origin, ray_dir, time, node, normal)) {
                random_index += uint(node) + uint(25182951 * time);

                // hit node
                vec3 cube = vec3(rand(), rand(), rand()) * 2 - 1;

                float phi = 2 * PI * rand();
                vec3 reflect_dir;
                reflect_dir.x = 2 * rand() - 1;
                float plane_radius = sqrt(1 - reflect_dir.x*reflect_dir.x);
                reflect_dir.y = plane_radius * cos(phi);
                reflect_dir.z = plane_radius * sin(phi);

                reflect_dir -= normal * min(0, 2 * dot(normal, reflect_dir));

                vec3 reflection = reflect(ray_dir, normal);
                reflect_dir = normalize(mix(reflect_dir, reflection, 0.15));

                vec3 color = node_color(node);
                vec3 emmitance = node_emmitance(node);

                sample_color += emmitance * blending_factor;
                blending_factor *= 2 * color * dot(normal, reflect_dir);

                ray_origin += ray_dir * time + 1e-4 * normal;
                ray_dir = reflect_dir;
            } else {
                // hit the sky
                sample_color += sky * blending_factor;
                break;
            }
        }

        out_color += sample_color; // == vec3(0) ? blending_factor : sample_color;
    }

    out_color /= MAX_SAMPLES;

    imageStore(output_image, coord, vec4(out_color, 1));
}
